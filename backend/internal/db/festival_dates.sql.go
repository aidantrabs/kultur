// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: festival_dates.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFestivalDate = `-- name: CreateFestivalDate :one
INSERT INTO festival_dates (
    festival_id, year, start_date, end_date, is_tentative
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, festival_id, year, start_date, end_date, is_tentative, created_at
`

type CreateFestivalDateParams struct {
	FestivalID  pgtype.UUID `json:"festivalId"`
	Year        int32       `json:"year"`
	StartDate   pgtype.Date `json:"startDate"`
	EndDate     pgtype.Date `json:"endDate"`
	IsTentative pgtype.Bool `json:"isTentative"`
}

func (q *Queries) CreateFestivalDate(ctx context.Context, arg CreateFestivalDateParams) (FestivalDate, error) {
	row := q.db.QueryRow(ctx, createFestivalDate,
		arg.FestivalID,
		arg.Year,
		arg.StartDate,
		arg.EndDate,
		arg.IsTentative,
	)
	var i FestivalDate
	err := row.Scan(
		&i.ID,
		&i.FestivalID,
		&i.Year,
		&i.StartDate,
		&i.EndDate,
		&i.IsTentative,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFestivalDate = `-- name: DeleteFestivalDate :exec
DELETE FROM festival_dates
WHERE id = $1
`

func (q *Queries) DeleteFestivalDate(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFestivalDate, id)
	return err
}

const deleteFestivalDatesByFestivalID = `-- name: DeleteFestivalDatesByFestivalID :exec
DELETE FROM festival_dates
WHERE festival_id = $1
`

func (q *Queries) DeleteFestivalDatesByFestivalID(ctx context.Context, festivalID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFestivalDatesByFestivalID, festivalID)
	return err
}

const getFestivalDateByYear = `-- name: GetFestivalDateByYear :one
SELECT id, festival_id, year, start_date, end_date, is_tentative, created_at FROM festival_dates
WHERE festival_id = $1 AND year = $2
`

type GetFestivalDateByYearParams struct {
	FestivalID pgtype.UUID `json:"festivalId"`
	Year       int32       `json:"year"`
}

func (q *Queries) GetFestivalDateByYear(ctx context.Context, arg GetFestivalDateByYearParams) (FestivalDate, error) {
	row := q.db.QueryRow(ctx, getFestivalDateByYear, arg.FestivalID, arg.Year)
	var i FestivalDate
	err := row.Scan(
		&i.ID,
		&i.FestivalID,
		&i.Year,
		&i.StartDate,
		&i.EndDate,
		&i.IsTentative,
		&i.CreatedAt,
	)
	return i, err
}

const getFestivalDatesByFestivalID = `-- name: GetFestivalDatesByFestivalID :many
SELECT id, festival_id, year, start_date, end_date, is_tentative, created_at FROM festival_dates
WHERE festival_id = $1
ORDER BY year DESC
`

func (q *Queries) GetFestivalDatesByFestivalID(ctx context.Context, festivalID pgtype.UUID) ([]FestivalDate, error) {
	rows, err := q.db.Query(ctx, getFestivalDatesByFestivalID, festivalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FestivalDate{}
	for rows.Next() {
		var i FestivalDate
		if err := rows.Scan(
			&i.ID,
			&i.FestivalID,
			&i.Year,
			&i.StartDate,
			&i.EndDate,
			&i.IsTentative,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFestivalDatesByYear = `-- name: ListFestivalDatesByYear :many
SELECT fd.id, fd.festival_id, fd.year, fd.start_date, fd.end_date, fd.is_tentative, fd.created_at, f.slug, f.name, f.region, f.heritage_type, f.festival_type, f.summary
FROM festival_dates fd
JOIN festivals f ON f.id = fd.festival_id
WHERE fd.year = $1 AND f.is_published = true
ORDER BY fd.start_date ASC
`

type ListFestivalDatesByYearRow struct {
	ID           pgtype.UUID        `json:"id"`
	FestivalID   pgtype.UUID        `json:"festivalId"`
	Year         int32              `json:"year"`
	StartDate    pgtype.Date        `json:"startDate"`
	EndDate      pgtype.Date        `json:"endDate"`
	IsTentative  pgtype.Bool        `json:"isTentative"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	Slug         string             `json:"slug"`
	Name         string             `json:"name"`
	Region       string             `json:"region"`
	HeritageType string             `json:"heritageType"`
	FestivalType string             `json:"festivalType"`
	Summary      string             `json:"summary"`
}

func (q *Queries) ListFestivalDatesByYear(ctx context.Context, year int32) ([]ListFestivalDatesByYearRow, error) {
	rows, err := q.db.Query(ctx, listFestivalDatesByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFestivalDatesByYearRow{}
	for rows.Next() {
		var i ListFestivalDatesByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.FestivalID,
			&i.Year,
			&i.StartDate,
			&i.EndDate,
			&i.IsTentative,
			&i.CreatedAt,
			&i.Slug,
			&i.Name,
			&i.Region,
			&i.HeritageType,
			&i.FestivalType,
			&i.Summary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingFestivalDates = `-- name: ListUpcomingFestivalDates :many
SELECT fd.id, fd.festival_id, fd.year, fd.start_date, fd.end_date, fd.is_tentative, fd.created_at, f.slug, f.name, f.region, f.heritage_type, f.festival_type, f.summary
FROM festival_dates fd
JOIN festivals f ON f.id = fd.festival_id
WHERE f.is_published = true
  AND fd.start_date >= CURRENT_DATE
  AND fd.start_date <= CURRENT_DATE + INTERVAL '30 days'
ORDER BY fd.start_date ASC
`

type ListUpcomingFestivalDatesRow struct {
	ID           pgtype.UUID        `json:"id"`
	FestivalID   pgtype.UUID        `json:"festivalId"`
	Year         int32              `json:"year"`
	StartDate    pgtype.Date        `json:"startDate"`
	EndDate      pgtype.Date        `json:"endDate"`
	IsTentative  pgtype.Bool        `json:"isTentative"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	Slug         string             `json:"slug"`
	Name         string             `json:"name"`
	Region       string             `json:"region"`
	HeritageType string             `json:"heritageType"`
	FestivalType string             `json:"festivalType"`
	Summary      string             `json:"summary"`
}

func (q *Queries) ListUpcomingFestivalDates(ctx context.Context) ([]ListUpcomingFestivalDatesRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingFestivalDates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUpcomingFestivalDatesRow{}
	for rows.Next() {
		var i ListUpcomingFestivalDatesRow
		if err := rows.Scan(
			&i.ID,
			&i.FestivalID,
			&i.Year,
			&i.StartDate,
			&i.EndDate,
			&i.IsTentative,
			&i.CreatedAt,
			&i.Slug,
			&i.Name,
			&i.Region,
			&i.HeritageType,
			&i.FestivalType,
			&i.Summary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFestivalDate = `-- name: UpdateFestivalDate :one
UPDATE festival_dates SET
    start_date = $2,
    end_date = $3,
    is_tentative = $4
WHERE id = $1
RETURNING id, festival_id, year, start_date, end_date, is_tentative, created_at
`

type UpdateFestivalDateParams struct {
	ID          pgtype.UUID `json:"id"`
	StartDate   pgtype.Date `json:"startDate"`
	EndDate     pgtype.Date `json:"endDate"`
	IsTentative pgtype.Bool `json:"isTentative"`
}

func (q *Queries) UpdateFestivalDate(ctx context.Context, arg UpdateFestivalDateParams) (FestivalDate, error) {
	row := q.db.QueryRow(ctx, updateFestivalDate,
		arg.ID,
		arg.StartDate,
		arg.EndDate,
		arg.IsTentative,
	)
	var i FestivalDate
	err := row.Scan(
		&i.ID,
		&i.FestivalID,
		&i.Year,
		&i.StartDate,
		&i.EndDate,
		&i.IsTentative,
		&i.CreatedAt,
	)
	return i, err
}
